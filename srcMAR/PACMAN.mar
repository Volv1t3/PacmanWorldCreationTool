/*Recreacion de Pac-man en MARIEJS - Organizacion de Computadores - Felipe Grijalva - USFQ*/
/*Integrantes del Grupo: [Felipe Rodriguez {00330528}, Josue Ponce {00330341}, Santiago Arellano {00328370}]*/


/* Loop principal de la aplicacion. Este metodo se encarga de manejar la inicializacion de la pantalla a traves de la carga de variables 
/* como IndexColores , IndexDisplay, y Contador
/* @param IndexColores: apunta al inicio de nuestro arreglo de colores
/* @param IndexDisplay:  apunta al index de la primera posicion del display
/* @param Contador:  permite contador la cantidad de colores que se deben cargar (256 casilleros).
intMainLoopLoadGame, Clear
					 JnS cargaDeMapaYEntidadesAlDisplay
					 Load CONST_ONE
					 /*Regresamos counter a cero para siguiente uso*/
					 Load CONST_ZERO
					 Store Counter
					 JnS RevisionContadorMovimientosPoder
					 JnS ValidacionParedes
					 Load IndexEntityArrayInicio
					 Store IndexEntityArrayCopia
					 JnS whileLivesAreHigherThanZero
					 Load CONST_ONE
					 Halt

RevisionContadorMovimientosPoder, HEX 000
									Load CONST_MOVIMIENTOS_PERMITIDOS_PARA_COMER
									SkipCond 800
									Halt
									JumpI RevisionContadorMovimientosPoder

ValidacionParedes, HEX 000
					Load IndexEntityArrayCopia
					Subt CONST_ONE
					Store IndexEntityArrayCopia
					LoopEntities, Load IndexEntityArrayCopia
								Add CONST_ONE
								Store IndexEntityArrayCopia
								Load ContadorRevisionInicial
								Add CONST_ONE
								Store ContadorRevisionInicial
								Load ContadorRevisionInicial
								Subt CONST_FIVE
								SkipCond 800
								Jump Revision
								JumpI ValidacionParedes
Revision, LoadI IndexEntityArrayCopia
				Add CONST_ONE
				Store positionRevision
				LoadI positionRevision
				Subt CONST_GRID_COLOR_BLUE
				SkipCond 400
				Jump LoopEntities
				Load positionRevision
				Subt CONST_ONE
				Subt CONST_SIXTEEN
				Store positionRevision
				LoadI positionRevision
				Subt CONST_GRID_COLOR_BLUE
				SkipCond 400
				Jump LoopEntities
				Load positionRevision
				Add CONST_SIXTEEN
				Subt CONST_ONE
				Store positionRevision
				LoadI positionRevision
				Subt CONST_GRID_COLOR_BLUE
				SkipCond 400
				Jump LoopEntities
				Load positionRevision
				Add CONST_ONE
				Add CONST_SIXTEEN
				Store positionRevision
				LoadI positionRevision
				Subt CONST_GRID_COLOR_BLUE
				SkipCond 400
				Jump LoopEntities
				Halt
				
/*Loop principal de la partida, la idea de este metodo es mantener el estado del juego mientras pacman tenga vidas, reiniciando el 
/* puntero hacia el mapa de carga de los movimientos mientras pacman no haya sufrido cinco golpes de un fantasma que lo maten. Para esto, el metodo 
/* revisa las vidas constantemente, registrando que si existen todavia vidas, el programa difurca a varios metodos de control para reiniciar los movimientos 
/* si fuera necesario. En este caso, si tenemos vidas suficientes, no saltamos fuera del ciclo y seguimos 
/* iterando sobre todos los datos del sistema. Para el analisis del juego, pasamos a un metodo interno llamado 
/* internalGeneralMovementAndLogicLoops, encargado de difurcar la ejecucion del codigo dependiendo de las 
/* condiciones internas
/* @param ContadorDeVidas: contador de vidas de pacmkan, tiene un valor estandar de cinco
/* @param CONST_ONE: constante numerica de valor uno 
whileLivesAreHigherThanZero, HEX 000
							 whileTrue, Clear
										Load ContadorDeVidas
										SkipCond 0C00 /*Saltamos si llegamos a cero
										JumpI whileLivesAreHigherThanZero
										/*Si tenemos vidas todavia, pasamos a la logica principal 
										/* que nos permite continuar la ejecucion
										JnS internalGeneralMovementAndLogicLoops
										Load CONST_ONE
										JnS reviewIfMovementResetIsNeeded
										Load CONST_ONE
										
										
										Jump whileTrue

/* Loop interno, secundario pero crucial para el manejo de metodos de validacion de movimientos, de vidas, llamadas a
/* metodos de validacion de datos, etc. Este bloque se realiza mientras el valor del Contador no llegue a 100, en cuyo caso
/* reiniciamos el contador en el 
internalGeneralMovementAndLogicLoops, HEX 000
/* Para realizar este metodo, debemos primero revisar que entidad es la que estamos analizando, y conocinedo esto debemos de calcular la 
/* columna y la fila en la que esta entidad se encuentra.
									  /*Dentro de la architectura de nuestro juego, vamos a iterar sobre los 
									  /*movimientos permitidos en el arreglo y dentro de estos realizamos 
									  /*validaciones, etc*/
									 
									  Load CONST_ZERO
									  Store Counter
									  whileMovementsAreNotOneHundred, Load ContadorMovimientosRealizadosEnDecimal
									  								  Add CONST_ONE
																	  Store ContadorMovimientosRealizadosEnDecimal
																	   Load CONST_ONE_HUNDRED
																	   Subt ContadorMovimientosRealizadosEnDecimal
																	   SkipCond 800
																		JumpI internalGeneralMovementAndLogicLoops
																	   
																	   
																	  /*Podemos realizar validaciones y calculos*/
																	  /*pero para movernos realizamos revision de */
																	  /*contadores*/
																	  // Enceramos todos los valores booleanos
																	   JnS obtenerColumnaYFila
																 	   Load CONST_ONE

																	   // Verificamos que figura estamos trabajando
																	   JnS verificarEntidadEsPacman
																	   Load CONST_ONE

																	   //Revisamos si tenemos movimientos, si no 
																	   // regresamos directamente al main con la
																	   // llamada JumpI al JnS
																	   // Si tenemos un valor negativo (hay movimientos) 
																	   // entonces el metodo entra al review logic y realiza 
																	   // los movimientos
																	   Load ContadorMovimientosRealizadosEnDecimal
																	   Subt CONST_ONE_HUNDRED
																	   SkipCond 800
																	   JnS internalMovementRevisionLogic
																	   Load CONST_ONE

																	   Load ContadorMovimientosHechosConPowerUpComer
																	   Subt CONST_ZERO
																	   SkipCond 800
																	   JnS removeCanEatState
																	   // Luego de la revision de colisiones, realizamos un movimiento!
																	   JnS internallyMoveAnEntity
																	   Load CONST_ONE
																	  
																	   // Luego de revisar si tenemos movimientos, revisamos
																	   // si tenemos movimientos para saltar al loop
																	   Jump whileMovementsAreNotOneHundred
																	  
decrementByOneCanComerTimer, HEX 000
							 // Disminuimos en uno el movimiento, dado que luego de haber hecho un movimiento para determinar la constante, 
							 // todos los movimientos restantes cuentan como uno menos para este contador.
							 Load ContadorMovimientosHechosConPowerUpComer
							 Subt CONST_ONE
							 Store ContadorMovimientosHechosConPowerUpComer
							 JumpI decrementByOneCanComerTimer
removeCanEatState, HEX 000
					// 1. Quitamos al condicion para poder comer a otros
					Load CanComerFantasmas
					Load CONST_ZERO
					Store CanComerFantasmas
					JumpI removeCanEatState
									  
internalMovementRevisionLogic, HEX 000
							   // En primera instancia procedemos a revisar derecha, al igual que los 
							   // metodos anteriores, si la logica se ejecuta, saltamos hacia la direccion 
							   // del JnS 
							   LoadI IndexPointerToMovementArray
							   Subt CONST_MOVIMIENTO_DERECHA
							   SkipCond 400
							   JnS internallyReviewIfTopIsFree
							   Load CONST_ONE 
							   // Realizamos la logica
							   Load PosicionHexadecimalEntidadActual
							   Add CONST_ONE
							   Store PosicionHexadecimalEntidadActual

							   Load CoordenadaEntityColumnaActual
							   Add CONST_ONE
							   Store CoordenadaEntityColumnaActual
							   JnS internallyReviewCollisionsWithBoundaries
							   Load CONST_ONE
							   JumpI internalMovementRevisionLogic

internallyReviewIfTopIsFree, HEX 000
							  // Revisamos el movimiento
							  LoadI IndexPointerToMovementArray
							  Subt CONST_MOVIMIENTO_ARRIBA
							  SkipCond 400
							  JnS internalllyReviewIfLeftIsFree
							  Load CONST_ONE

							  // Realizamos la logica
							  Load PosicionHexadecimalEntidadActual
							  Subt CONST_SIXTEEN
							  Store PosicionHexadecimalEntidadActual

							  Load CoordenadaEntityFilaActual
							  Subt CONST_ONE
							  Store CoordenadaEntityFilaActual

							  // Revisamos colisiones
							  JnS internallyReviewCollisionsWithBoundaries
							  Load CONST_ONE
							  JumpI internalMovementRevisionLogic
							  
internalllyReviewIfLeftIsFree, HEX 000
							   // Revisamos el movimiento
							   LoadI IndexPointerToMovementArray
							   Subt CONST_MOVIMIENTO_IZQUIERDA
							   SkipCond 400
							   JnS internallyReviewIfBottomIsFree
							   Load CONST_ONE

							   //Realizamos la logica
							   Load PosicionHexadecimalEntidadActual
							   Subt CONST_ONE
							   Store PosicionHexadecimalEntidadActual

							   Load CoordenadaEntityColumnaActual
							   Subt CONST_ONE
							   Store CoordenadaEntityColumnaActual

							   JnS internallyReviewCollisionsWithBoundaries
							   Load CONST_ONE
							   JumpI internalMovementRevisionLogic

internallyReviewIfBottomIsFree, HEX 000
								// Revisamos el moviomiento final
								LoadI IndexPointerToMovementArray
								Subt CONST_MOVIMIENTO_ABAJO
								SkipCond 400
								Jump whileMovementsAreNotOneHundred //Regresamos al loop de movimientos original

								Load PosicionHexadecimalEntidadActual
								Add CONST_SIXTEEN
								Store PosicionHexadecimalEntidadActual

								Load CoordenadaEntityFilaActual
								Add CONST_ONE
								Store CoordenadaEntityColumnaActual

								JnS internallyReviewCollisionsWithBoundaries
								Load CONST_ONE
								JumpI internalMovementRevisionLogic
							   

/*Metodo que permite difurcar la revision de colisiones, la idea es tener una estructura similar al proceso anterior, difurcando en varias JnS calls
/* para validar las colisiones del movimiento
internallyReviewCollisionsWithBoundaries, HEX 000
										  Load CoordenadaEntityColumnaActual
										  Subt CONST_DISPLAY_LIMIT
										  SkipCond 800
										  Jump RevisarCoordenadaColumnaIzquierda
										  Load PosicionHexadecimalEntidadActual
										  Subt CONST_SIXTEEN
										  Store PosicionHexadecimalEntidadActual
										  Clear
										  Store CoordenadaEntityColumnaActual
										  Jump internalBlueBorderColisionDetection
RevisarCoordenadaColumnaIzquierda, Clear
								   Load CoordenadaEntityColumnaActual
								   SkipCond 000
								   Jump RevisarCoordenadaFilaAbajo
								   Load PosicionHexadecimalEntidadActual
								   Add CONST_SIXTEEN
								   Store PosicionHexadecimalEntidadActual
								   Load CONST_DISPLAY_LIMIT
								   Store CoordenadaEntityColumnaActual
									Jump internalBlueBorderColisionDetection
								   
RevisarCoordenadaFilaAbajo, Clear
							Load CoordenadaEntityFilaActual
							Subt CONST_DISPLAY_LIMIT
							SkipCond 800
							Jump RevisarCoordenadaFilaArriba
							Load PosicionHexadecimalEntidadActual
							Subt CONST_TWO_FIFTY_SIX
							Store PosicionHexadecimalEntidadActual
							Clear
							Store CoordenadaEntityFilaActual
							Jump internalBlueBorderColisionDetection

RevisarCoordenadaFilaArriba, Load CoordenadaEntityFilaActual
						SkipCond 000
						Jump internalBlueBorderColisionDetection
						Load PosicionHexadecimalEntidadActual
						Add CONST_TWO_FIFTY_SIX
						Store PosicionHexadecimalEntidadActual
						Load CONST_DISPLAY_LIMIT
						Store CoordenadaEntityFilaActual
						Jump internalBlueBorderColisionDetection
internalBlueBorderColisionDetection, Clear
									 LoadI PosicionHexadecimalEntidadActual
									 Subt CONST_GRID_COLOR_BLUE
									 SkipCond 400
									 JumpI internallyReviewCollisionsWithBoundaries
									
									 Load PosicionHexadecimalEntidadAnterior
									 Store PosicionHexadecimalEntidadActual
									 Load CoordenadaEntityColumnaAnterior
									 Store CoordenadaEntityColumnaActual
									 Load CoordenadaEntityFilaAnterior
									 Store CoordenadaEntityFilaActual

									 // Incrementamos el movimiento 
									 Load IndexPointerToMovementArray
									 Add CONST_ONE
									 Store IndexPointerToMovementArray
									 Load CONST_ONE
									 Store RepiteMovimiento
									 Jump whileMovementsAreNotOneHundred
									 


internallyMoveAnEntity, HEX 000
						// Revisamos si la entidad es pacman, si la es realizxamos toda la logica internamente 
						Load isEntityPacman
						Subt CONST_ONE
						SkipCond 400
						Jump reviewAndPaintIfEntityisCyanGhost

						// Realizamos la logica del programa
						LoadI PosicionHexadecimalEntidadActual
						Store PosicionHexadecimalEntityActAux
						Load CONST_GRID_COLOR_NEGRO
						StoreI PosicionHexadecimalEntidadAnterior

						// Si estamos con el powerup entramos a revisar si interceptamos antes del movimiento un 
						// fantasma en el camino de pacman que cause que todos se reinicie.
						

						// Antes de revisar si tenemos una moneda, revisamos si tenemos un powerup
						Load PosicionHexadecimalEntityActAux
						Subt CONST_GRID_COLOR_NARANJA
						SkipCond 0C00
						JnS updateGameTotalWhenFoundAndSetUpEatOtherCondition

						JnS ActualizarIndexEntity
						JnS reviewIfFuturePositionIsAGhost

						Load CanComerFantasmas
								Subt CONST_ONE
								SkipCond 0C00
								JnS decrementByOneCanComerTimer
						// Si no tenemos un powerup, continuamos con el chequeo de una moneda 
						Load PosicionHexadecimalEntityActAux
						Subt CONST_GRID_COLOR_MONEDA
						SkipCond 400
						Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

						Jump SumarMonedaATotal
						JumpI internallyMoveAnEntity

							

updateGameTotalWhenFoundAndSetUpEatOtherCondition, HEX 000
													// Cargamos la constante que permite ir a comer a alguien mas dentro del sistema
													Load CONST_ONE
													Store CanComerFantasmas

													// Definimos un temporizador de movimientos
													Load CONST_MOVIMIENTOS_PERMITIDOS_PARA_COMER
													Store ContadorMovimientosHechosConPowerUpComer
													Load PuntosDeLaPartidaAux
													Add CONST_ONE
													Store PuntosDeLaPartidaAux
													
													JumpI updateGameTotalWhenFoundAndSetUpEatOtherCondition

reviewIfFuturePositionIsAGhost, HEX 000
								// 1. Cargamos la posicion actual, es decir la posicion a la que tiene que moverse antes de imprimir.
								// y comparamos con un fantasma, si no lo es saltamos
								Load PosicionHexadecimalEntityActAux
								Subt CONST_GRID_COLOR_TURQUESA
								SkipCond 400
								Jump reviewIfFuturePositionIsARedGhost
								
								
								// 2. Si seguimos aqui significa que tenemo un fantasma turquesa en frente, ahora tenemos que difurcar para pacman si se regresa o le come
								Load CanComerFantasmas
								Subt CONST_ONE
								SkipCond 0C00
								JnS reviewIfFuturePositionIsAGhostCanComerAdapter
								JnS beEatenByGhostAndReturnToStart

								// 2. Cargamos la posicion de pacman nueva y la ponemos
								Load CONST_GRID_COLOR_YELLOW
								StoreI PosicionHexadecimalEntityActAux
								Load CONST_GRID_COLOR_NEGRO
								StoreI PosicionHexadecimalEntidadActual

								// 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
							    Load PosicionHexadecimalEntityActAux
								StoreI IndexEntityArrayInicio
								Load IndexPointerEntityArray
								Add CONST_ONE
								Store IndexPointerEntityArray

		
								// Regresamos al hilo principal
								JumpI internallyMoveAnEntity

reviewIfFuturePositionIsAGhostCanComerAdapter, HEX 000
											   JnS eatCyanGhostAndReturnToCorrectPosition
											   JumpI internallyMoveAnEntity
	

reviewIfFuturePositionIsARedGhost, Clear
									// 1. Cargamos la posicion actual, y revisamos si este es un fantasma rojo.
									Load PosicionHexadecimalEntityActAux
									Subt CONST_GRID_COLOR_ROJO
									SkipCond 400
									Jump reviewIfFuturePositionIsAGreenGhost

									// 2. Si seguimos aqui significa que tenemo un fantasma turquesa en frente, ahora tenemos que difurcar para pacman si se regresa o le come
									Load CanComerFantasmas
									Subt CONST_ONE
									SkipCond 0C00
									JnS reviewIfFuturePositionIsARedGhostCanComerAdapter
									JnS beEatenByGhostAndReturnToStart

									// 2. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
									

									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

							
									   
									// Regresamos al hilo principal
									JumpI reviewIfFuturePositionIsAGhost

reviewIfFuturePositionIsARedGhostCanComerAdapter, HEX 000
												  JnS eatRedGhostAndReturnToCorrectPosition
												  JumpI reviewIfFuturePositionIsAGhost

reviewIfFuturePositionIsAGreenGhost, Clear
									 // 1. Cargamos la posicion actual y revisamos si este es un fantasma verde
									 Load PosicionHexadecimalEntityActAux
									 Subt CONST_GRID_COLOR_VERDE
									 SkipCond 400
									 Jump reviewIfFuturePositionIsAPinkGhost

									 // 2. Si seguimos aqui significa que tenemo un fantasma turquesa en frente, ahora tenemos que difurcar para pacman si se regresa o le come
									 Load CanComerFantasmas
									 Subt CONST_ONE
									 SkipCond 0C00
									 JnS reviewIfFuturePositionIsAGreenGhostCanComerAdapter
									 JnS beEatenByGhostAndReturnToStart

// 3. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 4. Cargamos la posicion de pacman nueva en el arreglo de posiciones
									 
									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

									 // Regresamos al hilo principal
									JumpI reviewIfFuturePositionIsAGhost
									
reviewIfFuturePositionIsAGreenGhostCanComerAdapter, HEX 000
													JnS eatGreenGhostAndReturnToCorrectPosition
													JumpI reviewIfFuturePositionIsAGhost
reviewIfFuturePositionIsAPinkGhost, Clear
									// 1. Cargamos la posicion actual y evisamos si este es un fantasma rosado
									Load PosicionHexadecimalEntityActAux
									Subt CONST_GRID_COLOR_ROSADO
									SkipCond 400
									JumpI reviewIfFuturePositionIsAGhost

									// 2. Si seguimos aqui significa que tenemo un fantasma turquesa en frente, ahora tenemos que difurcar para pacman si se regresa o le come
									Load CanComerFantasmas
									Subt CONST_ONE
									SkipCond 0C00
									JnS reviewIfFuturePositionIsAPinkGhostCanComerAdapter
									JnS beEatenByGhostAndReturnToStart

// 2. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
								


									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

									 
									// Regresamos al hilo principal
									JumpI reviewIfFuturePositionIsAGhost

reviewIfFuturePositionIsAPinkGhostCanComerAdapter, HEX 000
													JnS eatPinkGhostAndReturnToCorrectPosition
													JumpI reviewIfFuturePositionIsAGhost
eatCyanGhostAndReturnToCorrectPosition, HEX 000
										// En este metodo, si entramos significa  que caimos no solo en tener un fantasma turquesa enfrente,
										// sino que tambien tenemos autorizado en el game loop comer a ese fantasma

										// 1. Tenemos que mover a nuestro fantasma a su posicion inicial
										JnS reviewCyanGhostRestartPositionAndMove
										

										// 2. Cargamos los puntos dado que si pudimos comer
										Load PuntosDeLaPartida
										Add CONST_TEN_IN_DEC
										Store PuntosDeLaPartida
										Output

										// 3. Regresamos al main loop
										JumpI reviewIfFuturePositionIsAGhost

reviewCyanGhostRestartPositionAndMove, HEX 000
									   // 1. Cargamos en una variable auxiliar la posicion original del fantasma turquesa 
									   Load CONST_ORIGINAL_FANTASMA_TURQUESA_LOCATION
									   Store PosicionHexadecimalGhostMovidoAux

									   // 2. Revisamos cada uno de sus laterales y la posicion original para ver a donde moverlo
									   // 2.1 Revisamos in place
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterCyanGhostPositionInEntityArrayAndMove

									   // 2.2 Revisamos a la derecha
									   Load PosicionHexadecimalGhostMovidoAux
									   Add CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterCyanGhostPositionInEntityArrayAndMove

									   // 2.3 Revisamos arriba
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_ONE
									   Subt CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterCyanGhostPositionInEntityArrayAndMove

									   // 2.4 Revisamos izquierda
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_SIXTEEN
									   SUBT CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterCyanGhostPositionInEntityArrayAndMove

									   // 2.5 Revisamos abajo
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_ONE
									   Add CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterCyanGhostPositionInEntityArrayAndMove

									   // 3. Salimos si no pudimos realizar el movimiento 
									   JumpI reviewCyanGhostRestartPositionAndMove
									   
										
RegisterCyanGhostPositionInEntityArrayAndMove, HEX 000
									  // 1. Aqui vamos a mover la figura, y guardar la posicion a donde fue en el arreglo general de posiciones

									  // 1.1 Cargamos la variable de posicion de arreglo, sumamos uno para entrar al cyan y guardamos el Aux
									  Load IndexPointerEntityArray
									  Store extractedPosition
									  Load IndexEntityArrayInicio
									  Add CONST_ONE
									  Store IndexPointerEntityArray

									  Load PosicionHexadecimalGhostMovidoAux
									  StoreI IndexPointerEntityArray

									  // 1.2 Revertimos el movimiento de indices para no desfazar el loop principal
									  Load extractedPosition
									  Store IndexPointerEntityArray

									  // 2. Pintamos la figura dentro del mapa en la posicion correspondiente 
									  Load CONST_GRID_COLOR_TURQUESA
									  StoreI PosicionHexadecimalGhostMovidoAux

									  // 3. Salimos
									  JumpI reviewCyanGhostRestartPositionAndMove


eatRedGhostAndReturnToCorrectPosition,  HEX 000
										// En este metodo, si entramos significa  que caimos no solo en tener un fantasma turquesa enfrente,
										// sino que tambien tenemos autorizado en el game loop comer a ese fantasma

										// 1. Tenemos que mover a nuestro fantasma a su posicion inicial
										JnS reviewRedGhostRestartPositionAndMove
									

										// 2. Cargamos los puntos dado que si pudimos comer
										Load PuntosDeLaPartida
										Add CONST_TEN_IN_DEC
										Store PuntosDeLaPartida
										Output

										// 3. Regresamos al main loop
										JumpI eatRedGhostAndReturnToCorrectPosition

reviewRedGhostRestartPositionAndMove, HEX 000
									  // Al igual que en el metodo para el fastama turquesa, tenemos que pasar por una revision inicial de la posicion posible para
									  // el movimiento y luego moverla y guardarla
									   // 1. Cargamos en una variable auxiliar la posicion original del fantasma turquesa 
									   Load CONST_ORIGINAL_FANTASMA_ROJO_LOCATION
									   Store PosicionHexadecimalGhostMovidoAux

									   // 2. Revisamos cada uno de sus laterales y la posicion original para ver a donde moverlo
									   // 2.1 Revisamos in place
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterRedGhostPositionInEntityArrayAndMove

									   // 2.2 Revisamos a la derecha
									   Load PosicionHexadecimalGhostMovidoAux
									   Add CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterRedGhostPositionInEntityArrayAndMove

									   // 2.3 Revisamos arriba
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_ONE
									   Subt CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterRedGhostPositionInEntityArrayAndMove

									   // 2.4 Revisamos izquierda
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_SIXTEEN
									   SUBT CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterRedGhostPositionInEntityArrayAndMove

									   // 2.5 Revisamos abajo
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_ONE
									   Add CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterRedGhostPositionInEntityArrayAndMove

									   // 3. Salimos si no pudimos realizar el movimiento 
									   JumpI reviewRedGhostRestartPositionAndMove

RegisterRedGhostPositionInEntityArrayAndMove, HEX 000
									 // 1.1 Cargamos la variable de posicion de arreglo, sumamos uno para entrar al rojo y guardamos el Aux
									  Load IndexPointerEntityArray
									  Store extractedPosition
									  Load IndexEntityArrayInicio
									  Add CONST_TWO
									  Store IndexPointerEntityArray

									  Load PosicionHexadecimalGhostMovidoAux
									  StoreI IndexPointerEntityArray

									  // 1.2 Revertimos el movimiento de indices para no desfazar el loop principal
									  Load extractedPosition
									  Store IndexPointerEntityArray

									  // 2. Pintamos la figura dentro del mapa en la posicion correspondiente 
									  Load CONST_GRID_COLOR_ROJO
									  StoreI PosicionHexadecimalGhostMovidoAux

									  // 3. Salimos
									  JumpI reviewRedGhostRestartPositionAndMove


eatGreenGhostAndReturnToCorrectPosition,  HEX 000
										// En este metodo, si entramos significa  que caimos no solo en tener un fantasma turquesa enfrente,
										// sino que tambien tenemos autorizado en el game loop comer a ese fantasma

										// 1. Tenemos que mover a nuestro fantasma a su posicion inicial
										JnS reviewGreenGhostRestartPositionAndMove
									

										// 2. Cargamos los puntos dado que si pudimos comer
										Load PuntosDeLaPartida
										Add CONST_TEN_IN_DEC
										Store PuntosDeLaPartida
										Output

										// 3. Regresamos al main loop
										JumpI eatGreenGhostAndReturnToCorrectPosition

reviewGreenGhostRestartPositionAndMove, HEX 000
										 // Al igual que en el metodo para el fastama turquesa, tenemos que pasar por una revision inicial de la posicion posible para
									  // el movimiento y luego moverla y guardarla
									   // 1. Cargamos en una variable auxiliar la posicion original del fantasma verde 
									   Load CONST_ORIGINAL_FANTASMA_VERDE_LOCATION
									   Store PosicionHexadecimalGhostMovidoAux

									   // 2. Revisamos cada uno de sus laterales y la posicion original para ver a donde moverlo
									   // 2.1 Revisamos in place
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterGreenGhostPositionInEntityArrayAndMove

									   // 2.2 Revisamos a la derecha
									   Load PosicionHexadecimalGhostMovidoAux
									   Add CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterGreenGhostPositionInEntityArrayAndMove

									   // 2.3 Revisamos arriba
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_ONE
									   Subt CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterGreenGhostPositionInEntityArrayAndMove

									   // 2.4 Revisamos izquierda
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_SIXTEEN
									   SUBT CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterGreenGhostPositionInEntityArrayAndMove

									   // 2.5 Revisamos abajo
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_ONE
									   Add CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterGreenGhostPositionInEntityArrayAndMove

									   // 3. Salimos si no pudimos realizar el movimiento 
									   JumpI reviewGreenGhostRestartPositionAndMove

RegisterGreenGhostPositionInEntityArrayAndMove, HEX 000
									   // 1.1 Cargamos la variable de posicion de arreglo, sumamos uno para entrar al rojo y guardamos el Aux
									   Load IndexPointerEntityArray
									  Store extractedPosition
									  Load IndexEntityArrayInicio
									  Add CONST_THREE
									  Store IndexPointerEntityArray

									  Load PosicionHexadecimalGhostMovidoAux
									  StoreI IndexPointerEntityArray

									  // 1.2 Revertimos el movimiento de indices para no desfazar el loop principal
									  Load extractedPosition
									  Store IndexPointerEntityArray

									  // 2. Pintamos la figura dentro del mapa en la posicion correspondiente 
									  Load CONST_GRID_COLOR_VERDE
									  StoreI PosicionHexadecimalGhostMovidoAux

									  // 3. Salimos
									  JumpI reviewGreenGhostRestartPositionAndMove


eatPinkGhostAndReturnToCorrectPosition, HEX 000
									  // Al igual que para todos los fantasmas anteriores, debemos de tener en cuenta a donde nos podemos mover
									  // 1. Tenemos que mover a nuestro fantasma a su posicion inicial
										JnS reviewPinkGhostRestartPositionAndMove
									

										// 2. Cargamos los puntos dado que si pudimos comer
										Load PuntosDeLaPartida
										Add CONST_TEN_IN_DEC
										Store PuntosDeLaPartida
										Output

										// 3. Regresamos al main loop
										JumpI eatPinkGhostAndReturnToCorrectPosition

reviewPinkGhostRestartPositionAndMove, HEX 000
										 // Al igual que en el metodo para el fastama turquesa, tenemos que pasar por una revision inicial de la posicion posible para
									  // el movimiento y luego moverla y guardarla
									   // 1. Cargamos en una variable auxiliar la posicion original del fantasma verde 
									   Load CONST_ORIGINAL_FANTASMA_ROSADO_LOCATION
									   Store PosicionHexadecimalGhostMovidoAux

									   // 2. Revisamos cada uno de sus laterales y la posicion original para ver a donde moverlo
									   // 2.1 Revisamos in place
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterPinkGhostPositionInEntityArrayAndMove

									   // 2.2 Revisamos a la derecha
									   Load PosicionHexadecimalGhostMovidoAux
									   Add CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterPinkGhostPositionInEntityArrayAndMove

									   // 2.3 Revisamos arriba
									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_ONE
									   Subt CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterPinkGhostPositionInEntityArrayAndMove

									   // 2.4 Revisamos izquierda
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_SIXTEEN
									   SUBT CONST_ONE
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterPinkGhostPositionInEntityArrayAndMove

									   // 2.5 Revisamos abajo
									   Load PosicionHexadecimalGhostMovidoAux
									   ADD CONST_ONE
									   Add CONST_SIXTEEN
									   Store PosicionHexadecimalGhostMovidoAux

									   Load PosicionHexadecimalGhostMovidoAux
									   Subt CONST_GRID_COLOR_NEGRO
									   SkipCond 400
									   JnS RegisterPinkGhostPositionInEntityArrayAndMove

									   // 3. Salimos si no pudimos realizar el movimiento 
									   JumpI reviewPinkGhostRestartPositionAndMove

RegisterPinkGhostPositionInEntityArrayAndMove, HEX 000
									    // 1.1 Cargamos la variable de posicion de arreglo, sumamos uno para entrar al rosado y guardamos el Aux
									   Load IndexPointerEntityArray
									  Store extractedPosition
									  Load IndexEntityArrayInicio
									  Add CONST_FOUR
									  Store IndexPointerEntityArray

									  Load PosicionHexadecimalGhostMovidoAux
									  StoreI IndexPointerEntityArray

									  // 1.2 Revertimos el movimiento de indices para no desfazar el loop principal
									  Load extractedPosition
									  Store IndexPointerEntityArray

									  // 2. Pintamos la figura dentro del mapa en la posicion correspondiente 
									  Load CONST_GRID_COLOR_ROSADO
									  StoreI PosicionHexadecimalGhostMovidoAux

									  // 3. Salimos
									  JumpI reviewPinkGhostRestartPositionAndMove


beEatenByGhostAndReturnToStart, HEX 000
								// En este caso, regresamos a pacman a la posicion inicial, esto claro esta dependiendo de la posicion a la que tiene  que ir y sy
								// hay algo ahi

								// Paso Base: Modificamos total de vidas
								Load ContadorDeVidas
								Subt CONST_ONE
								Store ContadorDeVidas

								// 1. Cargamos la posicion de pacman anterior
								Load CONST_ORIGINAL_PACMAN_LOCATION
								Store PosicionHexadecimalEntityActAux

								// 2. Revisamos si tenemos alguna colision
								// 2.1 Revisamos si la posicion correcta tiene una colision
								LoadI PosicionHexadecimalEntityActAux
								Subt CONST_GRID_COLOR_NEGRO
								SkipCond 0C00
								JumpI beEatenByGhostAndReturnToStart

								// 2.2 Si no se pudo directamente, revisamos a la derecha
								Load PosicionHexadecimalEntityActAux
								Add CONST_ONE
								Store PosicionHexadecimalEntityActAux
								
								LoadI PosicionHexadecimalEntityActAux
								Subt CONST_GRID_COLOR_NEGRO
								SkipCond 0C00
								JumpI beEatenByGhostAndReturnToStart

								// 2.3 Revertimos posicion anterior y revisamos arriba
								Load PosicionHexadecimalEntityActAux
								Subt CONST_ONE
								Subt CONST_SIXTEEN
								Store PosicionHexadecimalEntityActAux

								LoadI PosicionHexadecimalEntityActAux
								Subt CONST_GRID_COLOR_NEGRO
								SkipCond 0C00 
								JumpI beEatenByGhostAndReturnToStart

								// 2.4 Revertimos posicion y revisamos izquierda
								Load PosicionHexadecimalEntityActAux
								Add CONST_SIXTEEN
								Subt CONST_ONE
								Store PosicionHexadecimalEntityActAux

								Load PosicionHexadecimalEntityActAux
								Subt CONST_GRID_COLOR_NEGRO
								SkipCond 0C00
								JumpI beEatenByGhostAndReturnToStart

								// 2.5 Revertimos posicion y revisamos abajo
								Load PosicionHexadecimalEntityActAux
								Add CONST_ONE
								Add CONST_SIXTEEN
								Store PosicionHexadecimalEntityActAux

								Load PosicionHexadecimalEntityActAux
								Subt CONST_GRID_COLOR_NEGRO
								SkipCond 0C00
								JumpI beEatenByGhostAndReturnToStart

								// 2.6 Si no se puede hacer nada, no deberiamos llegar aqui entonces 
								JumpI beEatenByGhostAndReturnToStart



reviewAndPaintIfEntityisCyanGhost, Clear
									Load isEntityTurquesa
									Subt CONST_ONE	
									SkipCond 400
									Jump reviewAndPaintIfEntitiyisRedGhost

							 		// Realizamos la logica del metodo
									// 1. Como la posicion se actualiza al determinar un movimiento valido, 
									// siempre agarramos aqui el color de la posicion nueva que va a tener.
									LoadI PosicionHexadecimalEntidadActual
									Store ColorTemp
									JnS ActualizarIndexEntity
									

									// ! Antes de realizar el movimiento, debemos interceptar si la posicion a donde vamos es pacman
									Load ColorTemp
									Subt CONST_GRID_COLOR_YELLOW
									SkipCond 0C00
									JnS reviewCyanGhostIfEatenByOrEatsPacman
									
									LoadI IndexColorAnterior
									StoreI PosicionHexadecimalEntidadAnterior

									
									Load CONST_GRID_COLOR_TURQUESA
									StoreI PosicionHexadecimalEntidadActual

									
									
									Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reviewCyanGhostIfEatenByOrEatsPacman, HEX 000
									  // 1. Cargamos el valor de la constante para ver si tenemos que pasar al metodo de comer 
									  Load CanComerFantasmas
									  Subt CONST_ONE
									  SkipCond 0C00
									  JnS reDirectToEatCyanGhostAndReturnToCorrectPosition
									  JnS beEatenByGhostAndReturnToStart

									  // 2. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
									   Load IndexPointerEntityArray
									   Store extractedPosition


									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

									   Load extractedPosition
									   Store IndexPointerEntityArray
									   
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadAnterior

									  // 2. Regresamos normalemtne 
									  Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reDirectToEatCyanGhostAndReturnToCorrectPosition, HEX 000
												  JnS eatCyanGhostAndReturnToCorrectPosition
												  Jump IndexMovimientoMasUnoYReconstruccionDeArreglo
reviewAndPaintIfEntitiyisRedGhost,  Clear
									Load isEntityRojo
									Subt CONST_ONE
									SkipCond 400
									Jump reviewAndPaintIfEntityisGreenGhost

									LoadI PosicionHexadecimalEntidadActual
									Store ColorTemp
									JnS ActualizarIndexEntity

									
									Load ColorTemp
									Subt CONST_GRID_COLOR_YELLOW
									SkipCond 0C00
									JnS reviewRedGhostIfEatenByOrEatsPacman
									
									LoadI IndexColorAnterior
									StoreI PosicionHexadecimalEntidadAnterior
									Load CONST_GRID_COLOR_ROJO
									StoreI PosicionHexadecimalEntidadActual
									
									
									Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reviewRedGhostIfEatenByOrEatsPacman, HEX 000
									 // 1. Cargamos el valor de la constante para ver si tenemos que pasar al modo comer 
									 Load CanComerFantasmas
									 Subt CONST_ONE
									 SkipCond 0C00
									 JnS reDirectToEatRedGhostAndReturnToCorrectPosition
									 JnS beEatenByGhostAndReturnToStart

									 // 2. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
									   Load IndexPointerEntityArray
									   Store extractedPosition


									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

									   Load extractedPosition
									   Store IndexPointerEntityArray
									   
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadAnterior
									

									 //2. Regresamos normalmente 
									 Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reDirectToEatRedGhostAndReturnToCorrectPosition, HEX 000
									JnS eatRedGhostAndReturnToCorrectPosition
									Jump IndexMovimientoMasUnoYReconstruccionDeArreglo
reviewAndPaintIfEntityisGreenGhost, Clear
									Load isEntityVerde
									Subt CONST_ONE
									SkipCond 400
									Jump reviewAndPaintIfEtityisPinkGhost

									LoadI PosicionHexadecimalEntidadActual
									Store ColorTemp
									JnS ActualizarIndexEntity

									// Revisamos pacman en donde nos tenemos que mover
									Load ColorTemp
									Subt CONST_GRID_COLOR_YELLOW
									SkipCond 0C00
									JnS reviewGreenGhostIfEatenByOrEatsPacman
									
									LoadI IndexColorAnterior
									StoreI PosicionHexadecimalEntidadAnterior
									
									Load CONST_GRID_COLOR_VERDE
									StoreI PosicionHexadecimalEntidadActual

									
									
									Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reviewGreenGhostIfEatenByOrEatsPacman, HEX 000
									  //1.  Cargamos el valor de la constante para ver si comemos o no
									  Load CanComerFantasmas
									  Subt CONST_ONE
									  SkipCond 0C00
									  JnS reDirectToEatGreenGhostAndReturnToCorrectPosition
									  JnS beEatenByGhostAndReturnToStart

									  // 2. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
									   Load IndexPointerEntityArray
									   Store extractedPosition


									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

									   Load extractedPosition
									   Store IndexPointerEntityArray

									   Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadAnterior

									  // 2. Regresamos normalmente
									  Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reDirectToEatGreenGhostAndReturnToCorrectPosition, HEX 000
													JnS eatGreenGhostAndReturnToCorrectPosition
													Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reviewAndPaintIfEtityisPinkGhost,   Clear	
								    LoadI PosicionHexadecimalEntidadActual
									Store ColorTemp
									JnS ActualizarIndexEntity
									
									// 1. Interceptamos si existe pacman en nuestro destino
									Load ColorTemp
									Subt CONST_GRID_COLOR_YELLOW
									SkipCond 0C00 
									JnS reviewPinkGhostIfEatenByOrEatsPacman
									
									LoadI IndexColorAnterior
									StoreI PosicionHexadecimalEntidadAnterior
									
									Load CONST_GRID_COLOR_ROSADO
									StoreI PosicionHexadecimalEntidadActual

									
									
									
									Jump IndexMovimientoMasUnoYReconstruccionDeArreglo

reviewPinkGhostIfEatenByOrEatsPacman, HEX 000
									  //1.  Cargamos el valor de la constante para ver si comemos o no
									  Load CanComerFantasmas
									  Subt CONST_ONE
									  SkipCond 0C00
									  JnS reDirectToEatPinkGhostAndReturnToCorrectPosition
									  JnS beEatenByGhostAndReturnToStart

									  

									  // 2. Cargamos la posicion de pacman nueva y la ponemos
									  Load CONST_GRID_COLOR_YELLOW
									  StoreI PosicionHexadecimalEntityActAux
									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadActual

									   // 3. Cargamos la posicion de pacman nueva en el arreglo de posiciones
									   Load IndexPointerEntityArray
									   Store extractedPosition


									   Load PosicionHexadecimalEntityActAux
									   StoreI IndexEntityArrayInicio

									   Load extractedPosition
									   Store IndexPointerEntityArray
									   

									  Load CONST_GRID_COLOR_NEGRO
									  StoreI PosicionHexadecimalEntidadAnterior
									  // 2. Regresamos normalmente
									  JumpI reviewPinkGhostIfEatenByOrEatsPacman


reDirectToEatPinkGhostAndReturnToCorrectPosition, HEX 000
												  JnS eatPinkGhostAndReturnToCorrectPosition
												  Jump IndexMovimientoMasUnoYReconstruccionDeArreglo
ActualizarIndexEntity, HEX 000
					   Load PosicionHexadecimalEntidadActual
					   StoreI IndexPointerEntityArray
					   Load IndexPointerEntityArray
					   Add CONST_ONE
					   Store IndexPointerEntityArray
					   JumpI ActualizarIndexEntity


SumarMonedaATotal,   Clear
				     Load PuntosDeLaPartidaAux
					 Add CONST_ONE
					 Store PuntosDeLaPartidaAux
		             
		          	 Load PuntosDeLaPartida
					 Add CONST_ONE
					 Store PuntosDeLaPartida
					 Output 
		             Jump IndexMovimientoMasUnoYReconstruccionDeArreglo
					
				
IndexMovimientoMasUnoYReconstruccionDeArreglo, Clear
					 Load isEntityPacman
						Subt CONST_ONE
						SkipCond 000
						Jump RebuildEntities
						Load IndexPointerToMovementArray
						Add CONST_ONE
						Store IndexPointerToMovementArray
						Load ColorTemp
						Subt CONST_GRID_COLOR_MONEDA
						SkipCond 400
						Jump RevisionNaranja
						Jump GuadarColor


RebuildEntities, 	Clear
					LoadI IndexEntityArrayCopia
				 	Store LocationTemp
				 	Load CONST_GRID_COLOR_YELLOW
				 	StoreI LocationTemp
				 	Load IndexEntityArrayCopia
				 	Add CONST_ONE
				 	Store IndexEntityArrayCopia
				 	LoadI IndexEntityArrayCopia
				 	Store LocationTemp
				 	Load CONST_GRID_COLOR_TURQUESA
				 	StoreI LocationTemp
				 	Load IndexEntityArrayCopia
				 	Add CONST_ONE
				 	Store IndexEntityArrayCopia
					LoadI IndexEntityArrayCopia
					Store LocationTemp
					Load CONST_GRID_COLOR_ROJO
					StoreI LocationTemp
					Load IndexEntityArrayCopia
					Add CONST_ONE
					Store IndexEntityArrayCopia
					LoadI IndexEntityArrayCopia
					Store LocationTemp
					Load CONST_GRID_COLOR_VERDE
					StoreI LocationTemp
					Load IndexEntityArrayCopia
					Add CONST_ONE
					Store IndexEntityArrayCopia
					LoadI IndexEntityArrayCopia
					Store LocationTemp
					Load CONST_GRID_COLOR_ROSADO
					StoreI LocationTemp
					Load IndexEntityArrayInicio
					Store IndexEntityArrayCopia
					 Load PuntosDeLaPartidaAux
					 Subt CONST_TOTAL_MONEDAS
					 SkipCond 0C00
					 END2, Halt
					Load ContadorDeVidas
					SkipCond 400
					JumpI internallyMoveAnEntity
					Jump whileTrue
					
RevisionNaranja, Load ColorTemp
				Subt CONST_GRID_COLOR_NARANJA
				SkipCond 400
				Jump RevisionFantasmaEncimadeFantasmaTurquesa
				Jump GuadarColor
RevisionFantasmaEncimadeFantasmaTurquesa, Load ColorTemp
								Subt CONST_GRID_COLOR_TURQUESA
								SkipCond 400
								Jump RevisionFantasmaEncimadeFantasmaRojo
								LoadI IndexColorAnteriorInicio
								Store ColorTemp
								Jump GuadarColor
RevisionFantasmaEncimadeFantasmaRojo, Load ColorTemp
										Subt CONST_GRID_COLOR_ROJO
										SkipCond 400
										Jump RevisionFantasmaEncimadeFantasmaVerde
										Load IndexColorAnteriorInicio
										Add CONST_ONE
										Store IndexColorAnteriorAux
										LoadI IndexColorAnteriorAux
										Store ColorTemp
										Jump GuadarColor
RevisionFantasmaEncimadeFantasmaVerde, Load ColorTemp
										Subt CONST_GRID_COLOR_VERDE
										SkipCond 400
										Jump RevisionFantasmaEncimadeFantasmaRosado
										Load IndexColorAnteriorInicio
										Add CONST_TWO
										Store IndexColorAnteriorAux
										LoadI IndexColorAnteriorAux
										Store ColorTemp
										Jump GuadarColor
RevisionFantasmaEncimadeFantasmaRosado, Load ColorTemp
										Subt CONST_GRID_COLOR_ROSADO
										SkipCond 400
										Jump GuadarNegro
										Load IndexColorAnteriorInicio
										Add CONST_THREE
										Store IndexColorAnteriorAux
										LoadI IndexColorAnteriorAux
										Store ColorTemp
										Jump GuadarColor
GuadarNegro, Load CONST_GRID_COLOR_NEGRO
			Store ColorTemp
GuadarColor, Load ColorTemp
			StoreI IndexColorAnterior
MoveIndexColor,	Load isEntityRosado
				Subt CONST_ONE
				SkipCond 000
				Jump ReiniciarLoopEntity
				Load IndexColorAnterior
				Add CONST_ONE
				Store IndexColorAnterior
				Jump RebuildEntities
ReiniciarLoopEntity, Load IndexEntityArrayInicio
					Store IndexPointerEntityArray
					Clear
					Store ContadorDeEntidadEnAnalisis
					Load IndexColorAnteriorInicio
					Store IndexColorAnterior		
					Jump RebuildEntities

/* Metodo que se encarga de revisar si exsites movimiento spor hacer, la idea de este metdood es revisar si el total de movimiento (100) no se ha alcanzado
/* si no se ha alcanzado, el metodo continua saltando rapidamente hacia fuera, si no , reinicia todas las variables
/* @param CONST_ONE_HUNDRED: constante de 100 para los movimieintos
/* @param ContadorMovimientosRealizadosEnDecimal: contador interno para definir cuantos movimientos se han dado en una vida
/* @param CONST_POSICION_INICIAL_ARREGLO_MOVIMIENTOS: posicion estatica de la localizacion del arrelgo de movimientos
/* @param IndexPointerToMovementArray: varaible que determina el puntero hacia el arreglo de movimientos
reviewIfMovementResetIsNeeded, HEX 000
							   /*If zero early exit*/
							   Load CONST_ONE_HUNDRED
							   Subt ContadorMovimientosRealizadosEnDecimal
							    SkipCond 0C00
							   JumpI reviewIfMovementResetIsNeeded
							   Load CONST_ONE_HUNDRED
							 
							  
							   /*Si no hay espacios, entonces reiniciamos las direcciones*/
							   Load CONST_POSICION_INICIAL_ARREGLO_MOVIMIENTOS
							   Store IndexPointerToMovementArray
							   Load CONST_ZERO
							   Store ContadorMovimientosRealizadosEnDecimal
							   JumpI reviewIfMovementResetIsNeeded

/*Grupo de funciones de validacion para el tipo de entidad en analisis, la idea de estas funciones es regresar 
/* directamente al caller principal, es decir a verificarEntidadEsPacman si es que en alguno de los casos se ejecuto \
/* todo el trabajo interno. En cualquier momento la entidad de analisis debe ser alguna de las entidades abajo
/* por tanto, si la encontramos y marcamos su booleano, salimos directamente al verificarEntidadEsPacman que es 
/* el metodo padre de las llamadas JnS, para retornar rapidamente al main.
verificarEntidadEsPacman, HEX 000
                        // Revisamos el valor de la entidad, encadenamos llamadas JnS en esta seccion
                        Load ContadorDeEntidadEnAnalisis
                        Subt CONST_ONE
                        SkipCond 400
                        JnS verificarFantasmaTurquesa
                        Load CONST_ONE
                        Store isEntityPacman
                        JumpI verificarEntidadEsPacman

verificarFantasmaTurquesa, HEX 000
                        // Revisamos el valor de la entidad
                        Load ContadorDeEntidadEnAnalisis
                        Subt CONST_TWO
                        SkipCond 400
                        JnS verificarFantasmaRojo
                        Load CONST_ONE
                        Load CONST_ONE
                        Store isEntityTurquesa
                        JumpI verificarEntidadEsPacman

verificarFantasmaRojo, HEX 000
                        // Revisamos el valor de la entidad
                        Load ContadorDeEntidadEnAnalisis
                        Subt CONST_THREE
                        SkipCond 400
                        JnS verificarFantasmaVerde
                        Load CONST_ONE
                        Load CONST_ONE
                        Store isEntityRojo
                        JumpI verificarEntidadEsPacman

verificarFantasmaVerde, HEX 000
                        // Revisamos el valor de la entidad
                        Load ContadorDeEntidadEnAnalisis
                        Subt CONST_FOUR
                        SkipCond 400
                        JnS verificarFantasmaRosado
                        Load CONST_ONE
                        Load CONST_ONE
                        Store isEntityVerde
                        JumpI verificarEntidadEsPacman

verificarFantasmaRosado, HEX 000
                        // Revisamos el valor de la entidad
                        Load CONST_ONE
                        Load CONST_ONE
                        Store isEntityRosado
                        JumpI verificarEntidadEsPacman
		

obtenerColumnaYFila, HEX 000
					 JnS encerarTodosLosBooleanosDeEntidades
					 Load CONST_ONE
					 /*Aumentamos en uno el contador de entidades, moviendonos en cada una de las entidades
					 /*facilitando el analisis de la entidad basada en la identificacion posicional del valor*/
					 Load RepiteMovimiento
					 Subt CONST_ONE
					 SkipCond 400
					 Jump AumentarContadorEntidad
					 Jump obtenerColumnaYFila2
AumentarContadorEntidad, Load ContadorDeEntidadEnAnalisis
					 Add CONST_ONE
					 Store ContadorDeEntidadEnAnalisis
					 Jump obtenerColumnaYFila2
					 
					/*Cargamos los valores del arreglo de entidades (direcciones hex) 
					 /*en memoria y la asignamos a un identificador posicional para saber de donde se mueve y a */
					 /* donde regresar
obtenerColumnaYFila2,LoadI IndexPointerEntityArray
					 Store PosicionHexadecimalEntityActAux
					 Store PosicionHexadecimalEntidadActual
					 Store PosicionHexadecimalEntidadAnterior
					 /*Tomamos el valor de extractedPosition para 
					 /*calcular la columna y la fila*/
					 Load  PosicionHexadecimalEntidadAnterior
					 Subt  CONST_BASE_DEL_DISPLAY
					 Store extractedPosition
					 JnS extractColumnAndStore
					 Load CONST_ONE
					 JnS extractRowAndStore
					 Load CONST_ONE
					 Clear
					 Store RepiteMovimiento
					 JumpI obtenerColumnaYFila
extractColumnAndStore, HEX 000
					   JnS moduloOperation
					   Load extractedNumHlpr
					   Store CoordenadaEntityColumnaActual
					   Store CoordenadaEntityColumnaAnterior
					   JumpI extractColumnAndStore
extractRowAndStore, HEX 000
					JnS divisionOperation
					Load extractedCounter
					Store CoordenadaEntityFilaActual
					Store CoordenadaEntityFilaAnterior
					JumpI extractRowAndStore

/*Operacion de modulo simplificada y aislada a una funcion sin retorno JnS*/
moduloOperation, HEX 000
				Load extractedPosition
				Store extractedNumHlpr
				whileHigherThanZero, Load extractedNumHlpr
									 Subt CONST_TEN_IN_HEX	
							 		 SkipCond 800
									 JumpI moduloOperation
									 Store extractedNumHlpr
							 		 Jump whileHigherThanZero	


/*Modulo de division simplificado para que sea de un solo uso y sin dependencias a ninguna otra parte del codigo*/
divisionOperation,  HEX 000
					Load extractedPosition
					Store extractedNumHlpr
					Load CONST_ZERO
					Store extractedCounter
							whileNotZero,   load extractedNumHlpr 
							  				Subt CONST_TEN_IN_HEX
							  				SkipCond 800
											JumpI divisionOperation
											Store extractedNumHlpr
											Load extractedCounter
											Add CONST_ONE
											Store extractedCounter
											Jump whileNotZero

/*Metodo util para definir que todas las variables de analisis de entidades se vuelvan cero antes de realizar su analisis*/
encerarTodosLosBooleanosDeEntidades, HEX 000
									 Load CONST_ZERO
									 Store isEntityPacman
									 Store isEntityRojo
									 Store isEntityRosado
									 Store isEntityTurquesa
									 Store isEntityVerde
									 JumpI encerarTodosLosBooleanosDeEntidades

cargaDeMapaYEntidadesAlDisplay, HEX 000
								LoadI IndexPointerToColoresArray
								StoreI IndexDisplay
								Load IndexDisplay
								Add CONST_ONE
								Store IndexDisplay
								Load IndexPointerToColoresArray
								Add CONST_ONE
								Store IndexPointerToColoresArray
								Load Counter
								Add CONST_ONE
								Store Counter
								Subt CONST_LIMITE_MOVIMIENTOS
								SkipCond 800
								Jump intMainLoopLoadGame
									 
/*Variables*/
/* @defintion: variables auxiliares requeridas para el manejo de modulo y division
extractedPosition, HEX 000
extractedCounter, DEC 0
extractedNumHlpr, HEX 000
/* @definition: Variables requeridas para el manejo de constantes
CONST_ZERO, DEC 0
CONST_ONE, DEC 1
CONST_TWO, DEC 2
CONST_THREE, DEC 3
CONST_FOUR, DEC 4 
CONST_FIVE, DEC 5
CONST_TEN_IN_DEC, DEC 10
CONST_TEN_IN_HEX, HEX 10
CONST_DISPLAY_LIMIT, DEC 15
CONST_SIXTEEN, DEC 16
CONST_ONE_HUNDRED, DEC 100
CONST_TOTAL_MONEDAS, DEC 29

CONST_LIMITE_MOVIMIENTOS, DEC 255
CONST_TWO_FIFTY_SIX, DEC 256
CONST_POSICION_INICIAL_ARREGLO_MOVIMIENTOS, HEX 565 /* cambiar cuando aades lineas
CONST_MOVIMIENTO_DERECHA, DEC 1
CONST_MOVIMIENTO_ARRIBA, DEC 2
CONST_MOVIMIENTO_IZQUIERDA, DEC 3
CONST_MOVIMIENTO_ABAJO, DEC 4
CONST_BASE_DEL_DISPLAY, HEX F00
/* @definition:Variables requeridas para el manejo de colores y sus referencias
CONST_GRID_COLOR_YELLOW, HEX 6767
CONST_GRID_COLOR_BLUE, HEX 001F
CONST_GRID_COLOR_TURQUESA, HEX 1BFE
CONST_GRID_COLOR_ROJO, HEX F08A
CONST_GRID_COLOR_VERDE, HEX 0F00
CONST_GRID_COLOR_ROSADO, HEX FDDC
CONST_GRID_COLOR_NEGRO, HEX 0000
CONST_GRID_COLOR_NARANJA, HEX F5A0
CONST_GRID_COLOR_MONEDA, HEX FFFF
/* @definition: Variables requeridas para el manejo de posiciones iniciales en caso de tener que reiniciar 
/* las posiciones de los fantasmas o de pacman a las posiciones iniciales
CONST_ORIGINAL_PACMAN_LOCATION, HEX FB7 /*cambiar en cambio de mapa
CONST_ORIGINAL_FANTASMA_TURQUESA_LOCATION, HEX F77  /*cambiar en cambio de mapa
CONST_ORIGINAL_FANTASMA_ROJO_LOCATION, HEX F67  /*cambiar en cambio de mapa
CONST_ORIGINAL_FANTASMA_VERDE_LOCATION, HEX F78  /*cambiar en cambio de mapa
CONST_ORIGINAL_FANTASMA_ROSADO_LOCATION, HEX F68  /*cambiar en cambio de mapa
/* @definition: Variables requeridas para el manejo del ciclo de vida del programa
/* contadores, vidas, puntaje.
ContadorDeVidas, DEC 5
CanComerFantasmas, DEC 0
CONST_MOVIMIENTOS_PERMITIDOS_PARA_COMER, DEC 32
ContadorMovimientosHechosConPowerUpComer, DEC 0
ContadorMovimientosRealizadosEnDecimal, DEC 0
Counter, DEC 0
ContadorRevisionInicial, DEC 0 
PuntosDeLaPartida, DEC 0
PuntosDeLaPartidaAux, DEC 0
ContadorDeEntidadEnAnalisis, DEC 0
IndexPointerToMovementArray, HEX 565 /*cambio cuando aades lineas
IndexDisplay, HEX F00
/* @definition: Varaibles requeridas para el manejo posicional y el analisis de las entidades dentro 
/* del juego.
CoordenadaEntityFilaActual, DEC 0
CoordenadaEntityFilaAnterior, DEC 0
CoordenadaEntityColumnaActual, DEC 0
CoordenadaEntityColumnaAnterior, DEC 0
PosicionHexadecimalEntidadActual, HEX 000
PosicionHexadecimalEntidadAnterior, HEX 000
PosicionHexadecimalEntityActAux, HEX 000
PosicionHexadecimalGhostMovidoAux, HEX 000
IndexPointerEntityArray, HEX 458 /*cambio cuando aades lineas
IndexEntityArrayCopia, HEX 458 /*cambio cuando aades lineas
IndexEntityArrayInicio, Hex 458 /*cambio cuando aades lineas
ithPositionInMovementArray, DEC 0
IndexPointerToColoresArray, HEX 465 /*cambio cuando aades lineas
LocationTemp, HEX 000
positionRevision, HEX 000
/* @definition: Variables requeridas para el manejo de control logico del programa, especificamente, del tipo de estructura que 
/* estamos revisando, como por ejemplo, que tipo de fantasma es
isEntityPacman, DEC 0
isEntityTurquesa, DEC 0
isEntityRojo, DEC 0
isEntityVerde, DEC 0
isEntityRosado, DEC 0
RepiteMovimiento, DEC 0
/* @definition: Variables controladores para la informacion de memoria que se trae de la aplicacion interna
EntityArray, HEX FB7  /*cambiar en cambio de mapa
			HEX F77
			HEX F67
			HEX F78
			HEX F68
ColorTemp, HEX 000
IndexColorAnterior, HEX 461 /* Cambiar siempre a la posicion de memoria a donde apunta ColorAnteriorArray 
							/* en su primera posicion
IndexColorAnteriorInicio, HEX 461 /*Duplicar el inicio para poder regresar
IndexColorAnteriorAux, HEX 461 /*Duplicar el inicio para poder regresar
ColorAnteriorArray, Hex 000
					Hex 000
					Hex 000
					Hex 000
colorLocationArrayForRow, HEX 000
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX F5A0
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX FFFF
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX FFFF
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX F08A
                     HEX FDDC
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 1BFE
                     HEX 0F00
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX FFFF
                     HEX 000
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX 000
                     HEX f5A0
                     HEX 6767
                     HEX f5a0
                     HEX 000
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX FFFF
                     HEX 000
                     HEX 000
                     HEX F5A0
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 001F
                     HEX 001F
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
                     HEX 000
movementListValues, DEC 3
                    DEC 2
                    DEC 2
                    DEC 3
                    DEC 2
                    DEC 1
                    DEC 4
                    DEC 4
                    DEC 3
                    DEC 3
                    DEC 4
                    DEC 3
                    DEC 3
                    DEC 3
                    DEC 1
                    DEC 3
                    DEC 4
                    DEC 4
                    DEC 3
                    DEC 2
                    DEC 1
                    DEC 2
                    DEC 3
                    DEC 1
                    DEC 4
                    DEC 3
                    DEC 4
                    DEC 4
                    DEC 2
                    DEC 3
                    DEC 4
                    DEC 2
                    DEC 2
                    DEC 4
                    DEC 1
                    DEC 4
                    DEC 2
                    DEC 4
                    DEC 2
                    DEC 4
                    DEC 3
                    DEC 1
                    DEC 1
                    DEC 4
                    DEC 4
                    DEC 2
                    DEC 4
                    DEC 2
                    DEC 4
                    DEC 2
                    DEC 1
                    DEC 4
                    DEC 2
                    DEC 2
                    DEC 4
                    DEC 1
                    DEC 4
                    DEC 2
                    DEC 1
                    DEC 2
                    DEC 1
                    DEC 2
                    DEC 3
                    DEC 1
                    DEC 1
                    DEC 1
                    DEC 2
                    DEC 2
                    DEC 4
                    DEC 4
                    DEC 3
                    DEC 4
                    DEC 2
                    DEC 2
                    DEC 1
                    DEC 2
                    DEC 1
                    DEC 2
                    DEC 1
                    DEC 4
                    DEC 2
                    DEC 4
                    DEC 1
                    DEC 3
                    DEC 4
                    DEC 1
                    DEC 1
                    DEC 3
                    DEC 2
                    DEC 1
                    DEC 2
                    DEC 1
                    DEC 1
                    DEC 2
                    DEC 1
                    DEC 3
                    DEC 4
                    DEC 3
                    DEC 3
                    DEC 1
